<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alex Liang</title>
  
  <subtitle>在新創公司擔任軟體工程師，記錄我的學習歷程</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://alexliang.me/"/>
  <updated>2023-01-19T01:08:36.656Z</updated>
  <id>https://alexliang.me/</id>
  
  <author>
    <name>Alex Liang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 golang-migrate 執行 database migration</title>
    <link href="https://alexliang.me/%E4%BD%BF%E7%94%A8-golang-migrate%E5%9F%B7%E8%A1%8C-database-migration/"/>
    <id>https://alexliang.me/使用-golang-migrate執行-database-migration/</id>
    <published>2023-01-18T15:16:19.000Z</published>
    <updated>2023-01-19T01:08:36.656Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子團隊使用<a href="https://github.com/golang-migrate/migrate">golang-migrate</a>對 Cassandra 進行 migration。</p><p>覺得順手後，想用它當做 PostgreSQL migration tool。</p><p>這篇文章記錄該如何使用 golang-migrate 撰寫 docker-compose 檔案及 github action 的 yaml </p><span id="more"></span><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>假如要在本地端起一台 PG 和執行 migration，使用 docker 會是比較方便的選擇。以下為 docker-compose.yaml 的內容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:11.9</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./scripts:/docker-entrypoint-initdb.d/</span></span><br><span class="line">  <span class="attr">migrate:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">migrate/migrate</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;-path&quot;</span>, <span class="string">&quot;/migrations&quot;</span>, <span class="string">&quot;-database&quot;</span>,  <span class="string">&quot;postgresql://user:password@postgres:5432/db?sslmode=disable&quot;</span>, <span class="string">&quot;up&quot;</span> ]</span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./migrations:/migrations</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure><ul><li>PG 在初始化後要執行的任務放在 <code>./scripts</code> 並掛到 <code>docker-entrypoint-initdb.d</code>，例如建 schema</li><li>第二個 service migrate/migrate 是本文的主角，其 migration command 可以到官網查詢。</li><li>由於 migration 要等 PG 初始化並允許連線才能執行，這裡用 <code>restart: on-failure</code> 不斷的去試，直到連到 DB 為止。</li></ul><h2 id="github-action"><a href="#github-action" class="headerlink" title="github action"></a>github action</h2><p>如果在 github 上跑 CI 需要設定 github action。這裡以 node.js + PostgreSQL 為例，說明如何使用 golang-migrate:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Unit</span> <span class="string">Test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">release</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;feat/*&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;fix/*&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;refactor/*&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;chore/*&#x27;</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">      <span class="attr">POSTGRES_DB:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">password</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">services:</span></span><br><span class="line">      <span class="attr">postgres:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">postgres:11.9</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">POSTGRES_DB:</span> <span class="string">$&#123;&#123;env.POSTGRES_DB&#125;&#125;</span></span><br><span class="line">          <span class="attr">POSTGRES_USER:</span> <span class="string">$&#123;&#123;env.POSTGRES_USER&#125;&#125;</span></span><br><span class="line">          <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">$&#123;&#123;env.POSTGRES_PASSWORD&#125;&#125;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">5432</span><span class="string">:5432</span></span><br><span class="line">        <span class="attr">volumes:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">/migrations:/migrations</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span> <span class="number">16.16</span><span class="number">.0</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">16.16</span><span class="number">.0</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Schema</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        psql postgresql://$&#123;&#123;env.POSTGRES_USER&#125;&#125;:$&#123;&#123;env.POSTGRES_PASSWORD&#125;&#125;@localhost:5432/$&#123;&#123;env.POSTGRES_DB&#125;&#125;?sslmode=disable -c &#x27;CREATE SCHEMA IF NOT EXISTS demo;&#x27;</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">migrations</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">docker://migrate/migrate</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">args:</span> <span class="string">&quot;-path ./migrations -database postgresql://$<span class="template-variable">&#123;&#123;env.POSTGRES_USER&#125;&#125;</span>:$<span class="template-variable">&#123;&#123;env.POSTGRES_PASSWORD&#125;&#125;</span>@postgres:5432/$<span class="template-variable">&#123;&#123;env.POSTGRES_DB&#125;&#125;</span>?sslmode=disable up&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        npm install</span></span><br><span class="line"><span class="string">        npm run test</span></span><br></pre></td></tr></table></figure><ul><li>在 Create Schema 階段執行 <code>psql</code> 指令</li><li>在 Run migrations 階段使用 <code>uses</code> 指定 docker image path，並帶入 migration 指令</li></ul><p>以上是 docker-compose 和 github action 使用 golang-migrate 執行 migration 的設定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前陣子團隊使用&lt;a href=&quot;https://github.com/golang-migrate/migrate&quot;&gt;golang-migrate&lt;/a&gt;對 Cassandra 進行 migration。&lt;/p&gt;
&lt;p&gt;覺得順手後，想用它當做 PostgreSQL migration tool。&lt;/p&gt;
&lt;p&gt;這篇文章記錄該如何使用 golang-migrate 撰寫 docker-compose 檔案及 github action 的 yaml &lt;/p&gt;
    
    </summary>
    
    
      <category term="devops" scheme="https://alexliang.me/tags/devops/"/>
    
      <category term="database" scheme="https://alexliang.me/tags/database/"/>
    
      <category term="docker" scheme="https://alexliang.me/tags/docker/"/>
    
      <category term="github" scheme="https://alexliang.me/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>&lt;我想和你聊一聊&gt; 讀後感</title>
    <link href="https://alexliang.me/%E6%88%91%E6%83%B3%E5%92%8C%E4%BD%A0%E8%81%8A%E4%B8%80%E8%81%8A-%E8%AE%80%E5%BE%8C%E6%84%9F/"/>
    <id>https://alexliang.me/我想和你聊一聊-讀後感/</id>
    <published>2023-01-02T05:31:47.000Z</published>
    <updated>2023-01-19T01:11:06.524Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子在臉書上看到某位名人在推<a href="https://www.books.com.tw/products/0010936474">這本書</a>，稱它解決了多年來管理和溝通的難題。到書店翻了一下，結合了學理和實務經驗，並且附上許多範例。</p><p>如果你在給予指導、反饋時擔心傷了對方，或老是當個好人報喜不報憂。這本書能為你提供改善的方法。</p><span id="more"></span><h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>本書主要是以主管的角度談論該如何:</p><ul><li>給予下屬回饋，該怎麼說真話</li><li>如何表達賞識</li><li>指導訣竅</li></ul><p>作者泰蕾絲．休斯頓（Therese Huston）為認知心理學博士。</p><p>書中引用大量的學術研究和作者實際指導的案例，並且附上模擬情境的對話，說明該如何應用。</p><h2 id="本書適合誰"><a href="#本書適合誰" class="headerlink" title="本書適合誰"></a>本書適合誰</h2><p>這本書適合</p><ul><li>正在當主管，想精進溝通能力 </li><li>想要當主管的人 </li><li>家中有學齡兒童的父母</li></ul><p>之所以列出父母親，我認為親子之間也時常有指導、讚美的對話。</p><p>使用本書提到的溝通原則，對於親子之間的互動會有很大的幫助。</p><h2 id="該怎麼說真話"><a href="#該怎麼說真話" class="headerlink" title="該怎麼說真話"></a>該怎麼說真話</h2><p>對大多上班族來說，每年(半年)的績效考核是一個既期待又怕受傷害的場合。</p><p>同樣的，對主管來說也不輕鬆。要提出下屬表現出色的部分；或是指出他們待改進的地方。</p><p>作者提出一個重要的觀點: <em>給予回饋時，主角是對方而不是自己</em>。</p><p>這句話的意思是: 我們應該把心態由”說教”改為”協助”對方。</p><p>從這個角度出發，我們應該思考:</p><ul><li>對方需要什麼回饋</li><li>如何讓對方聽的進去</li></ul><p>本書的前言舉了一位健身教練的案例，由於她的教學風格和健身房、學員的期待不相符，業績一直沒有起色。</p><p>直到主管向她說明情況，並站在她的角度建議應該換個環境試試看。</p><p>即使這是解雇的過程，主管還是肯定該教練的潛力並傾聽對方的想法。</p><p>當然，主管們對於指出缺點、說壞消習的對話會有很大的壓力。這本書也提供了很多句型和心態調整的方法。</p><h2 id="如何進行彼此都獲益的對話"><a href="#如何進行彼此都獲益的對話" class="headerlink" title="如何進行彼此都獲益的對話"></a>如何進行彼此都獲益的對話</h2><p>有沒有遇過主管/父母在不清楚全貌的情況下給你指導或負面的回饋呢？</p><p>大多數人在這種情況下會覺得無辜且無所適從，可能對主管/父母多了一層防備心。</p><p>書中提到一位飯店櫃檯人員的例子就是上面描述的情況。</p><p>而作者提出的方法是: <em>多問少說，傾聽、引導想出新解方 </em></p><p>她建議主管們在指導時先問幾個問題，表明你在傾聽和關心對方。</p><p>這其實是要指導者有更多的好奇心，藉由提問了解對方真正的問題是什麼，而不是以自己的角度給予建議。</p><p>經由提問、引導的過程，可以讓雙方有效的解決問題。</p><h2 id="讀後感想"><a href="#讀後感想" class="headerlink" title="讀後感想"></a>讀後感想</h2><p>看完這本書才更清楚知道以前遇過的指導和回饋具體是哪些讓自己不舒服或無感。</p><p>如果喜歡看心理學相關的書，這本提到很多的實驗可以讓我們更了解人性。</p><p>作者引用某個實驗證明權力越大的人，換位思考能力越弱。</p><p>本書提出的方法需要多加練習。作者在各章節做了整理，不時穿插流程圖協助對話的進行。</p><p>想改善溝通技巧和帶人的心法可以參考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前陣子在臉書上看到某位名人在推&lt;a href=&quot;https://www.books.com.tw/products/0010936474&quot;&gt;這本書&lt;/a&gt;，稱它解決了多年來管理和溝通的難題。到書店翻了一下，結合了學理和實務經驗，並且附上許多範例。&lt;/p&gt;
&lt;p&gt;如果你在給予指導、反饋時擔心傷了對方，或老是當個好人報喜不報憂。這本書能為你提供改善的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="讀書心得" scheme="https://alexliang.me/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>工程師在淡季可以做的事</title>
    <link href="https://alexliang.me/%E5%B7%A5%E7%A8%8B%E5%B8%AB%E5%9C%A8%E6%B7%A1%E5%AD%A3%E5%8F%AF%E4%BB%A5%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    <id>https://alexliang.me/工程師在淡季可以做的事/</id>
    <published>2022-12-26T00:16:15.000Z</published>
    <updated>2022-12-29T15:19:55.387Z</updated>
    
    <content type="html"><![CDATA[<p>如果你在外商，或是客戶大多在國外。每年到了聖誕節左右應該會有一段時間會是沒什麼 loading 的狀態。</p><p>又或者大部分台灣公司，在農曆新年前也不太會上新功能，工程師們會多出一些時間。</p><p>這時候除了發呆裝忙，還能做些什麼呢？ (這篇絕對不是叫各位上班刷題 LOL)</p><span id="more"></span><h2 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h2><p>工程師都很討厭專案或流程沒有文件，但偏偏又不喜歡自己寫文件。</p><p>在空檔時期將重要的流程整理起來，相信同事和未來的自己會很感謝你。</p><p>假如需要記錄每個 service 之間的溝通方式，自己很常用 <a href="https://plantuml.com/en/sequence-diagram">sequence-diagram</a>。它可以幫助 team member 更快了解整個流程，也可以知道 service 之間怎麼互動。</p><p>使用 VS code 的人，有 <a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml">PlantUML plugin</a> 可以安裝。</p><p>JetBrains 系列的 IDE 也有 <a href="https://plugins.jetbrains.com/plugin/7017-plantuml-integration">PlantUML</a>。</p><p>我習慣將這些 UML 檔放在專案裡，要編輯或查閱都很方便。</p><h2 id="翻新-Onboarding-手冊"><a href="#翻新-Onboarding-手冊" class="headerlink" title="翻新 Onboarding 手冊"></a>翻新 Onboarding 手冊</h2><p>另一個可以做的事情就是翻新 onboarding 手冊。在軟體架構越來越複雜的情況下，不論是剛加入的成員或已經待一陣子的人，都會對整個系統見樹不見林。如果每次都用口頭或白板說明，是一件很沒效益的事。</p><p>在這個時候你可以寫 onboarding 手冊，或是新人剛入職時，跑完 onboarding process 也能幫忙更新過期的內容。</p><p>將這些文件化的好處是所有人都能減少被詢問打斷的時間，新人也能更快上手。</p><h2 id="還技術債"><a href="#還技術債" class="headerlink" title="還技術債"></a>還技術債</h2><p>過去一直沒時間還的技術債可以趁這段時間補起來，或是一直沒寫的測試也能在此時補齊。</p><p>我們都能理解在時間緊迫下，必須 work around 完成某些功能。但基礎不穩固的系統是無法一直加新功能的。</p><p>在空檔時間，把過去不好的設計整理一下，能讓之後的開發更順利。</p><h2 id="分享知識"><a href="#分享知識" class="headerlink" title="分享知識"></a>分享知識</h2><p>在上述項目都做完，也許你該向 team member 分享過程遇到的困難及解決的方法。</p><p>讓整個小組一起變強，這也是團隊運作越來越有效率的關鍵。</p><blockquote><p>團隊戰力就像一個浴桶一樣，能裝多少水取決於最短的木片。</p></blockquote><blockquote><p>假如每個成員都很強，那浴桶就能裝更多水，大家的開發體驗也就更好了。</p></blockquote><p>以上是工程師在空檔時間可以去做的事情。有其它不錯項目也歡迎留言分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你在外商，或是客戶大多在國外。每年到了聖誕節左右應該會有一段時間會是沒什麼 loading 的狀態。&lt;/p&gt;
&lt;p&gt;又或者大部分台灣公司，在農曆新年前也不太會上新功能，工程師們會多出一些時間。&lt;/p&gt;
&lt;p&gt;這時候除了發呆裝忙，還能做些什麼呢？ (這篇絕對不是叫各位上班刷題 LOL)&lt;/p&gt;
    
    </summary>
    
    
      <category term="職涯發展" scheme="https://alexliang.me/tags/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 EXPLAIN 調校 SQL 查詢</title>
    <link href="https://alexliang.me/%E4%BD%BF%E7%94%A8-EXPLAIN-%E8%AA%BF%E6%A0%A1-SQL-%E6%9F%A5%E8%A9%A2/"/>
    <id>https://alexliang.me/使用-EXPLAIN-調校-SQL-查詢/</id>
    <published>2022-12-16T02:13:59.000Z</published>
    <updated>2022-12-22T14:15:54.912Z</updated>
    
    <content type="html"><![CDATA[<p>遇到 SQL 查詢效能不彰時，除了 review SQL 以外，使用 EXPLAIN 可以了解效能低落的原因。</p><p>這篇文章介紹如何使用這個指令及解讀回傳的結果。</p><span id="more"></span><h2 id="Query-Process"><a href="#Query-Process" class="headerlink" title="Query Process"></a>Query Process</h2><p>要解釋 EXPLAIN 前，需要了解 PostgreSQL 在查詢的內部流程。主要有下列步驟:</p><ul><li>Parser: 如同編譯器一樣，PostgreSQL 需要將人看的懂的 SQL 翻譯成它能執行的語言 (<em>query tree</em>)</li><li>Rewrite: 調整 query tree，分解 views 到對應的 table</li><li><strong>Planner</strong>: 由 query tree 規劃該如何快速地找到資料。這個步驟跟 query 效能直接相關</li><li>Execute: 執行 query</li></ul><p>使用 EXPLAIN 能讓我們知道 query 會如何執行，接下來說明它的用法。</p><h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>基本的用法是在 SQL 最前面加上 <code>EXPLAIN</code>，則查詢結果回傳 <em>query plan</em>。也就是預估每次下 SQL 查詢時，背後的 planner 讀取多少 row, index 並且花了多少資源。</p><p><em>假如要真的執行 SQL，可使用 <code>EXPLAIN ANALYZE</code>，則 PG 會執行並分析此 SQL。</em></p><p>以下面 SQL 為例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">JOIN</span> public.address <span class="keyword">ON</span> address.employee_id <span class="operator">=</span> employees.id</span><br><span class="line"><span class="keyword">WHERE</span> first_name <span class="operator">=</span> <span class="string">&#x27;Alex&#x27;</span></span><br></pre></td></tr></table></figure><p>回傳結果會是</p><p><img src="explain.png" alt="explain result"></p><p>逐一分析結果:</p><ul><li>Hash Join  (cost=20.18..43.69 rows=5 width=120) 執行 JOIN 的預估，此操作需要將一張表讀進 memory 再根據條件找出記錄<ul><li>cost 是猜測此 SQL 要花多少時間執行。裡面包含二個數字: 前者為隨機找二筆記錄需要的時間；後者表示逐一檢視記錄的總成本</li><li>rows 為猜測需要掃描多少筆記錄</li><li>width 為猜測平均每筆記錄的長度 (bytes)    </li></ul></li><li>Hash Cond: (address.employee_id = employees.id) 使用 employee id 去 address table 找對應的記錄</li><li>-&gt;  Seq Scan on address  (cost=0.00..20.70 rows=1070 width=48) 逐一掃描 address 的成本</li><li>-&gt;  Hash  (cost=20.12..20.12 rows=4 width=72) </li><li>-&gt;  Seq Scan on employees  (cost=0.00..20.12 rows=4 width=72) 逐一掃描 employees 的預估成本</li><li>Filter: (first_name = ‘Alex’::text) 使用 first_name 當查詢條件</li></ul><p>在 query planner 階段，PostgreSQL 會比較隨機找出記錄和逐一掃描 heap file 需要的成本。</p><p>如果使用 index，會從 B+ tree root node 隨機找 child page 再搜尋對應的 heap file。一般來說，會比逐一找記錄來的快。</p><p>假如使用 pgadmin 的話有按鈕可以執行 EXPLAIN </p><p><img src="pgadmin_explain.png" alt="pgadmin_explain"></p><p>它也可以用圖形的方式呈現 query plan</p><p><img src="explain_graphical.png" alt="explain_graph"></p><p><em>要注意使用 GUI 就不用在 SQL 加上 EXPLAIN</em></p><p>除了 Join 的 query plan, PostgreSQL 官方文件有列出各種 EXPLAIN 結果。如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;</span><br><span class="line"></span><br><span class="line">                                 QUERY PLAN</span><br><span class="line">-------------------------------------------------------------------​----------</span><br><span class="line"> Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 width=244)</span><br><span class="line">   Index Cond: (unique1 = 42)</span><br></pre></td></tr></table></figure><p>此 SQL 使用 index column 查詢，query planner 呈現 index scan 結果。</p><p>在調校 SQL query 時，可藉由 EXPLAIN 分析需要的成本及過程。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.postgresql.org/docs/current/using-explain.html#USING-EXPLAIN-BASICS">Using EXPLAIN</a></li><li><a href="https://www.udemy.com/course/sql-and-postgresql/">SQL and PostgreSQL: The Complete Developer’s Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遇到 SQL 查詢效能不彰時，除了 review SQL 以外，使用 EXPLAIN 可以了解效能低落的原因。&lt;/p&gt;
&lt;p&gt;這篇文章介紹如何使用這個指令及解讀回傳的結果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="postgresql" scheme="https://alexliang.me/tags/postgresql/"/>
    
      <category term="database" scheme="https://alexliang.me/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>淺談 concurrency 和 parallelism 以 Node.js為例</title>
    <link href="https://alexliang.me/%E6%B7%BA%E8%AB%87-concurrency-%E5%92%8C-parallelism-%E4%BB%A5%20Node-js%E7%82%BA%E4%BE%8B/"/>
    <id>https://alexliang.me/淺談-concurrency-和-parallelism-以 Node-js為例/</id>
    <published>2022-11-29T14:52:25.000Z</published>
    <updated>2022-12-11T13:09:51.303Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到 concurrency 和 parallelism 比較的文章，把相關的概念和 Node.js 如何應用做個整理</p><span id="more"></span><h2 id="Concurrency-與-Parallelism"><a href="#Concurrency-與-Parallelism" class="headerlink" title="Concurrency 與 Parallelism"></a>Concurrency 與 Parallelism</h2><p>首先要說明 concurrency 興 parallelism 的不同: <strong>concurrency 是指工作在重疊的時間內執行；parallelism 則是工作在完全相同的時間內執行</strong></p><p>以下圖為例:</p><p><img src="concurrency_parallelism.drawio.png" alt="concurrency vs. parallelism"></p><p>在計算機組織的概念裡，concurrency 相當於 pipeline。把一件任務分成很多階段交給不同的單位處理，同一時間每個單位只處理一個工作。</p><p>而 parallelism 則是 CPU 多核心的概念，每個核心可各自處理任務，同一時間有多個核心消化請求。</p><p>了解這二個概念後，我們再來看 Javascript 和 Node.js </p><h2 id="Javascript-with-Single-Thread"><a href="#Javascript-with-Single-Thread" class="headerlink" title="Javascript with Single Thread"></a>Javascript with Single Thread</h2><p>多數人學習 Javascript 都是從瀏覽器或 Node.js 環境開始執行程式，教材都會強調 JS 為單執行緒語言。實務上，不管 JS 用在前端(瀏覽器)或後端(Node.js) 主要處理非同步事件，如滑鼠點擊按鈕，或前端送請求到後端查詢資料。</p><p>這裡就帶到 JS 有名的 callback function，可以設定某個事件發生時，程式要如何回應。如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">button.on(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something when button has been clicked </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`event: <span class="subst">$&#123;event&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="string">``</span><span class="string">`                                </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面這段程式碼告訢瀏覽器當 button 被點擊時，要做回應並印出 log。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Node.js Event Loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">進到 Node.js 環節。它是以 [google V8 引擎](https://v8.dev/) 為核心，讓 javascript 撰寫的程式能提供 API service。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">API service 主要處理由前端(或其它 service) 打進來的 request，回傳資料和運算結果。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">這裡面需要不斷地監聽外界傳進來的 request，收到後要查詢 Cache/database，最後再回傳。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而 Node.js 是如何應付成千上萬的 request 呢？ 答案就在 event loop 設計</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以下為 Event loop 在 Node.js server 的概念圖</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![Event loop in Node.js](https://media.geeksforgeeks.org/wp-content/uploads/20200224050909/nodejs2.png)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Event loop 是一個不斷地處理外界 request 的無窮迴圈。這些 request 被加進 event queue 後依序處理。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">圖示的 thread pool 集中 Node.js 對 I/O 和系統操作的 thread (執行緒)。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">從這個角度來看，Node.js 還是有使用多執行緒，只不過 developer 在寫 Node.js 程式時，多半是以單執行緒的方式完成工作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">而 Event loop 從 queue 拿取工作後會經過下列步驟:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">![Event loop process](https://media.geeksforgeeks.org/wp-content/uploads/20200224062607/phasesofloop-300x240.png)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">各步驟的細節可以到 [這篇文章](https://notes.andywu.tw/2020/%E5%AE%8C%E6%95%B4%E5%9C%96%E8%A7%A3node-js%E7%9A%84event-loop%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88/) 查看。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Node.js server 收到 request 後便將工作丟到 event queue 裡，隨即處理下一個 request。同時，event loop 經過數個步驟處理非同步和運算的流程。整個分工模式就像是 concurrency vs. parallelism 那張圖所描繪的 concurrency。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">這也是為何 Node.js 不適合作運算量大的服務，當 event loop 在處理工作時，需要等運算結果出來才能完成 callback。在正常情況下，這種操作會讓 service 的 response 拉的很長。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Multi-Thread in Node.js</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">看完 Node.js 在 concurrency 的實作，假如想在 Node.js 寫 multi-thread 程式，該怎麼做呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Node.js 提供二種原生的方式:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1. [Cluster](https://nodejs.org/api/cluster.html) 可產生隔離的 multi-process application</span></span><br><span class="line"><span class="string">2. [worker_threads](https://nodejs.org/api/worker_threads.html) 適合每個 process 的隔離不是必要且 worker 之間需要資料交換</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### Cluster </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以下為簡單的範例說明如何使用 cluster 建立 multi-thread 版本的 HTTP server</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">import</span> cluster <span class="keyword">from</span> <span class="string">&#x27;node:cluster&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> http <span class="keyword">from</span> <span class="string">&#x27;node:http&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isPrimary()) &#123;</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">&#x27;hello world\n&#x27;</span>);</span><br><span class="line">  &#125;).listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cluster.isPrimary()</code> 用來判斷是否在主程序</li><li><code>cluster.fork()</code> 建立 worker</li><li>在每個 worker 建立 HTTP server 監聽 port 3000 並回應 hello world</li></ul><p>如果細心看會發現每個 worker 都監聽同一個 port，為何這樣寫是可以的呢？</p><p>在 Node.js cluster 裡，任何對 <code>listen()</code> 的呼叫會讓 Node.js 去監聽主程序而不是 worker。</p><p>主程序預設會採 round-robin 方式分配新的請求，當主程序收到 request 時，會透過 IPC 傳遞給其它 worker。</p><p>以上的範例說明如何使用 cluster 建立多程序的程式，但如果需要在不同 worker 間共享資料得使用另一種方式。</p><h3 id="worker-threads"><a href="#worker-threads" class="headerlink" title="worker_threads"></a>worker_threads</h3><p>要加快運算量大(CPU-intense)的流程時，<a href="https://nodejs.org/api/worker_threads.html">worker_threads</a> 能解決這個問題。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  Worker, </span><br><span class="line">  isMainThread, </span><br><span class="line">  parentPort</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:worker_threads&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_THREAD_COUNT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">  <span class="keyword">let</span> workingThreadNum = MAX_THREAD_COUNT;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; MAX_THREAD_COUNT; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(__filename);</span><br><span class="line">    worker.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg === <span class="string">&quot;done&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--workingThreadNum === <span class="number">0</span>) &#123;</span><br><span class="line">          process.stdout.write(<span class="string">`count: <span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        process.stdout.write(msg.toString() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; hashFunc &#125; = <span class="built_in">require</span>(<span class="string">&quot;some-library&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">1000000</span> / MAX_THREAD_COUNT; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> randomNum = random64();</span><br><span class="line">    parentPort.postMessage(hashFunc(randomNum));</span><br><span class="line">  &#125; </span><br><span class="line">  parentPort.postMessage(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 new Worker 建立一個 worker thread。 <code>__filename</code> 表示目前的檔案</li><li>建立4個 worker threads，並在最後一個收到完成任務的 worker 印出總共處理的數目</li><li>假如不是 isMainThread，引入某個 hash function 並透過 <code>postMessage</code> 傳送結果</li><li><code>parentPort</code> 為 worker 的 <a href="https://nodejs.org/api/worker_threads.html#class-messageport">MessagePort</a>，提供雙向溝通，藉此和 main thread 交換訊息。</li></ul><p>在操作 multi-thread 時，很重要的一點便是共享記億體的保護。這已超出本文主題，留待之後再寫文章補充。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.tenlong.com.tw/products/9786263241671?list_name=srh">JavaScript 多執行緒｜超越事件迴圈的並行 (Multithreaded JavaScript)</a></li><li><a href="https://www.geeksforgeeks.org/node-js-event-loop/">Node.js Event Loop</a></li><li><a href="https://notes.andywu.tw/2020/%E5%AE%8C%E6%95%B4%E5%9C%96%E8%A7%A3node-js%E7%9A%84event-loop%E4%BA%8B%E4%BB%B6%E8%BF%B4%E5%9C%88/">完整圖解Node.js的Event Loop(事件迴圈)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前看到 concurrency 和 parallelism 比較的文章，把相關的概念和 Node.js 如何應用做個整理&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://alexliang.me/tags/Node-js/"/>
    
      <category term="backend" scheme="https://alexliang.me/tags/backend/"/>
    
  </entry>
  
  <entry>
    <title>成功轉職工程師，然後呢？</title>
    <link href="https://alexliang.me/%E6%88%90%E5%8A%9F%E8%BD%89%E8%81%B7%E5%B7%A5%E7%A8%8B%E5%B8%AB%EF%BC%8C%E7%84%B6%E5%BE%8C%E5%91%A2%EF%BC%9F/"/>
    <id>https://alexliang.me/成功轉職工程師，然後呢？/</id>
    <published>2022-11-19T13:44:46.000Z</published>
    <updated>2022-11-22T14:12:56.378Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://alexliang.me/%E5%B0%8D%E6%96%BC%E8%BD%89%E8%81%B7%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%94%E6%9C%83/">上一篇</a>文章提到轉職工程師該注意的事情。這篇分享轉職後該怎麼面對接下來的挑戰。</p><span id="more"></span><h2 id="心態"><a href="#心態" class="headerlink" title="心態"></a>心態</h2><p>剛入行的工程師都會遇到一個心態問題: <strong>冒牌者症候群</strong>。不管是不是本科系，進入理想的公司後都會懷疑自己是否夠格。</p><p>其實，不論你的實力能不能完成工作，與其一直懷疑自己，不如認真的聽同事、mentor 解釋系統架構和確認需求。</p><p>code review 時被寫了很多待改進的地方也不用氣餒。換個角度想，學到新的技巧還有錢拿，這是自己賺到，下次別犯一樣的錯就好。</p><p>在新人蜜月期時，多問多寫筆記，不會有人嫌煩。但過了一段時間還對系統不了解，那就是自己的問題了。</p><p>把自己的心態從我是不是進錯地方，換成我要在二年內獨當一面，激勵自己快速成長是很重要的。</p><h2 id="優秀工程師的習慣"><a href="#優秀工程師的習慣" class="headerlink" title="優秀工程師的習慣"></a>優秀工程師的習慣</h2><p>與其它工程師共事時，觀察他是如何完成工作的。看到特別的操作技巧(如 IDE 快速鍵或 terminal 的指令)，一定要趕快請教。</p><p>看過的優秀工程師都有一個習慣: <em>凡事都要找到最省力的方式完成</em></p><p>他們會盡量用自動化指令或最少的步驟，在設計流程時也傾向走最好懂、省力的方式，讓自己不用一直救火。</p><p>他們絕少用錯的方式 trial and error，反而在下手前會想很久，一出手就能精準解決問題。</p><p>他們甚至會跟 PM/設計師討論需求，務求時間花在刀口上。</p><p>他們會時常關注系統發生的不順或無效率流程，然後花幾天的時間幫公司省下 n 位工程師/月的成本。</p><p>這些都是進入公司後自己要學習觀察的地方，而大部分的 memtor/senior 沒時間手把手的教，得靠自己思考。</p><h2 id="持續學習"><a href="#持續學習" class="headerlink" title="持續學習"></a>持續學習</h2><p>剛轉職為工程師進入職場是成長曲線衝最快的時候，這時候除了之前上課所學，平常的工作也會帶來很多刺激。</p><p>過一段時間後，假如只靠公司 code review/memtor 指導，進步幅度會大幅受限。</p><p>每位工程師都要找到適合自己的學習方法，以下分享幾個自己常用的資源。</p><h3 id="閱讀"><a href="#閱讀" class="headerlink" title="閱讀"></a>閱讀</h3><p>由於程式語言和系統設計要解釋原理和場景得花很多篇幅，一本書能系統性的說明主題。我會建議買幾本基本原理、原則類的書，書單:</p><ul><li><a href="https://www.tenlong.com.tw/products/9789865021832?list_name=b-r7-zh_tw">重構｜改善既有程式的設計, 2/e</a> Martin Fowler 的書值得多讀幾次 </li><li><a href="https://www.tenlong.com.tw/products/9789862017050?list_name=b-r7-zh_tw">Clean Code</a> 不用說了，程式設計師必讀的書</li><li><a href="https://www.tenlong.com.tw/products/9789864342945?list_name=rd">無瑕的程式碼－整潔的軟體設計與架構篇</a> Clean code 的系統架構版</li><li><a href="https://www.tenlong.com.tw/products/9789864345618?list_name=srh">Kent Beck 的測試驅動開發：案例導向的逐步解決之道</a> Kent Beck 的書也是經典</li></ul><h3 id="線上資源"><a href="#線上資源" class="headerlink" title="線上資源"></a>線上資源</h3><p>除了看書，線上的資源也可以好好利用，比較常逛的有:</p><ul><li><a href="https://www.udemy.com/">Udemy</a>，習慣影音的教學可以來這裡看看。 (有特價時要好好把握)</li><li><a href="https://medium.com/">Medium</a>，可以依興趣訂閱 blog，很多大公司都在上面發文章。對於各語言、框架最新的資訊也是很齊全，可以訂閱它的電子報</li><li><a href="https://www.facebook.com/search/top?q=will%20%E4%BF%9D%E5%93%A5%E7%9A%84%E6%8A%80%E8%A1%93%E4%BA%A4%E6%B5%81%E4%B8%AD%E5%BF%83">Will 保哥的技術交流中心</a>，國內知名的開發者。從前端到後端、DevOps 都很有經驗，他經常在粉專分享各種解決問題和技術的心得。</li></ul><p>Blog 也是很好的知識管道，可以向厲害的人學習如何整理知識及培養對技術的敏銳度。我大多是看後端相關的 blog，如:</p><ul><li><a href="https://rickhw.github.io/">Complete Think</a>，91App 的 Rick 是經驗豐富的高手。他對技術管理也有想法，blog 整理的很棒。</li><li><a href="https://columns.chicken-house.net/">架構師的修練</a> 91App 的架構師，內容很有深度，值得細讀</li><li><a href="http://www.5233.space/search/label/%E8%81%B7%E6%A5%AD%E7%94%9F%E6%B6%AF">TS 資訊科技與人才培育</a>, Shopback 工程緦監的 blog，雖然很久沒更新了，但裡面有很多學習和技術管理的好文章。</li><li><a href="https://blog.gslin.org/">Gea-Suan Lin’s BLOG</a>, 也是技術圈的大大。 內容偏雲端新技術和 DevOps 的技術</li></ul><h3 id="線下課"><a href="#線下課" class="headerlink" title="線下課"></a>線下課</h3><p>如果想參加線下課程，91的<a href="https://tdd.best/courses/extreme-developing-202303/?fbclid=IwAR1RizsiFvAJAuA6o985GD5CHeq9SzptAavKeUuqhLXvKmRid87z4GbX70o">極速開發</a>和<a href="https://tdd.best/courses/unit-testing-gracefully-with-legacy-code-202301/">針對遺留代碼加入單元測試的藝術</a>都是很推薦的課程。</p><p>普通工程師和厲害的工程師除了差在大局觀，能在短時間把 code 寫的又快又好也是關鍵。這二堂課能學到其中的 mindset，是很棒的投資。</p><p>最後，希望這篇文章能幫助剛轉職的工程師，讓職涯走的順利。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://alexliang.me/%E5%B0%8D%E6%96%BC%E8%BD%89%E8%81%B7%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%94%E6%9C%83/&quot;&gt;上一篇&lt;/a&gt;文章提到轉職工程師該注意的事情。這篇分享轉職後該怎麼面對接下來的挑戰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="職涯發展" scheme="https://alexliang.me/tags/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>對於轉職軟體工程師的一些體會</title>
    <link href="https://alexliang.me/%E5%B0%8D%E6%96%BC%E8%BD%89%E8%81%B7%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%94%E6%9C%83/"/>
    <id>https://alexliang.me/對於轉職軟體工程師的一些體會/</id>
    <published>2022-11-01T14:23:44.000Z</published>
    <updated>2022-11-18T00:22:10.195Z</updated>
    
    <content type="html"><![CDATA[<p>從 fw 工程師轉職到後端也6年了。一開始，只是因為本來的工作遇到瓶頸，又嚮往矽谷純軟公司的文化才跳出原本的圈子。</p><p>這二年在 alpha camp 擔任助教，前後也指導過 4, 50位學生。</p><p>每枇學生畢業前都會有一個 office hour，需要回答他們的問題及給出建議。</p><p>這篇文章想整理多數轉職者的問題及自己的經驗。</p><span id="more"></span><h2 id="常見問題"><a href="#常見問題" class="headerlink" title="常見問題"></a>常見問題</h2><h3 id="作品集"><a href="#作品集" class="headerlink" title="作品集"></a>作品集</h3><p>這題是後端學生常有的問題，假如是前端，網路上有一堆 xx 網站的復刻練習或是<a href="https://dev.to/frontendmentor/16-front-end-projects-with-designs-to-help-improve-your-coding-skills-5ajl">各種模版/元件的project</a>可以參考。</p><p>至於後端，我給的建議通常是二個方向:</p><ol><li>從自己過去領域/生活遇到沒效率或大量手動處理的事，寫個程式或 chrome plug-in 去解決。例如你是財會相關的，一定會遇到許多數字相關的工作，能不能寫個套件去自動化處理。</li><li>上述方向沒想到題目，那就寫支爬蟲吧。它可以訓練: <ul><li>HTTP 相關的操作，遇到需要下 query 或帶 token 的，以及如何產生目標 URL</li><li>處理 HTML，需要將有用的資訊抽出來，這部分需要了解 HTML/CSS 的結構</li><li>將有用的資訊存到 DB 裡，甚至設計 data pipeline 有效率的存放資料 (如何排程爬蟲、分階段取 raw data 和 content)</li></ul></li></ol><p>這些作品不用很大或很複雜，但可以很好地證明自己的能力。</p><h3 id="寫履歷、面試"><a href="#寫履歷、面試" class="headerlink" title="寫履歷、面試"></a>寫履歷、面試</h3><p>轉職者遇到的另一個問題是寫履歷和面試。這部分可以視為新鮮人找工作的情況，要引起用人主管/HR的興趣進而得到面試機會。</p><p>履歷基本的撰寫原則在各家工作媒合平台都有文章可參考，如<a href="https://www.yourator.co/articles/177">履歷怎麼寫？使用 STAR 原則，讓你的工作經歷 / 學歷更耀眼！</a>或<a href="https://www.yourator.co/articles/323">專長與興趣有哪些？沒有專長履歷怎麼寫？給新鮮人的專長、興趣尋找指南！</a></p><p>把自己過去做出成績的部分寫進履歷(最好能量化)，目的是說明自己有潛力能帶來貢獻。</p><p>履歷調整完後，最好請認識的工程師幫忙 review。</p><p>假如沒有認識的工程師，建議第一版可以先丟不太有興趣/可有可無的公司，先試試看水溫。</p><p>在面試前，別忘了先去找各個程式語言常考的問題，如<a href="https://www.guru99.com/javascript-interview-questions-answers.html">Top 100 JavaScript Interview Questions and Answers (2022)</a>。通常針對 junior engineer，主要是考觀念。</p><p>如果面試過程中遇到不會的問題，也不用硬擠出答案，記下來回去再找解答，確保下一次碰到時能正確回答。</p><p>這也是第一階段為何先投練兵用的公司。</p><p>不管在職涯哪個階段，面試都是需要準備和熟悉的流程，讓自己多點經驗再去面想要的工作，成功的機率會高一些。</p><h2 id="Offer-選擇"><a href="#Offer-選擇" class="headerlink" title="Offer 選擇"></a>Offer 選擇</h2><p>最後，當手上有幾個 offer 可以選擇時，該如何挑適合自己的職位？</p><p>撇開公司產品、地點和薪水(這點等等會提)，對於轉職新手工程師來說，第一份工作重要的事情只有一個: <strong>如何快速的提升自己</strong></p><p>因為不是本科系，本來在市場求職就吃虧了。如果一開始就進到不好的環境，學到錯誤的習慣和觀念。即使拿的薪水比其它間好，對將來的發展會是一大阻礙。</p><p>那要怎麼衡量手上的 offer 呢？以公司/產品時間軸和團隊成熟度區分，可以分成</p><p><img src="company_team_matrix.png" alt="company_team_matrix"></p><p><em>這只是簡單的二分法，實際上公司發展進程可以切好幾個階段。同一間公司，不同的產品線也有不同的時間軸</em></p><p>公司發展進程具體來說可以用以下幾點判斷:</p><ol><li>已經有產品的 MVP 嗎?</li><li>產品是否達到 prodcuct market fit? </li><li>公司開始賺錢？</li><li>公司已有幾個成熟產品，獲利和營收都很穩定</li></ol><p>越符合後面的要素，表示這間公司越成熟。也代表內部已有一套流程。</p><p>而工程團隊成熟度可以用下列角度思考:</p><ol><li>工程主管在業界有豐富的經驗或具體的成績</li><li>有沒有導入 CI/CD、code review 及寫文件等流程</li><li>各職位是否有專責人員，例如 QA、SRE 等等</li><li>團隊大部分成員都是有經驗的人 (可以去 Linkedin 搜尋)</li><li>團隊會定期分享技術文章或參與社群活動</li></ol><p>如果這幾個問題都是否定的答案，那表示工程團隊的成熟度較低。</p><p>從轉職工程師的角度來看，建議不要去剛起步的公司和工程團隊成熟度低的地方。</p><p>原因是這些公司通常還在摸索產品的方向，時程趕、資源少，新手進去可能會學到不好的習慣或是很快陣亡。</p><p>最理想的狀況是公司發展成熟+工程團隊很強，有很多可以學習的對象。這對轉職者來說會進步的很快。</p><p>在選擇 offer 時，別只看薪資、地點或 title，要加入未來成長性的考量。</p><p>進到好的環境，在自己肯學的情況下，會有不斷的機會可以磨練技術。只要做出成績，提高薪資也是自然而然的事。</p><p>假如自己沒拿到這種 offer 呢？以我的看法，把團隊成熟度高放在第一優先。在這個階段提升自己才是最重要的。</p><h2 id="轉職成功，然後呢？"><a href="#轉職成功，然後呢？" class="headerlink" title="轉職成功，然後呢？"></a>轉職成功，然後呢？</h2><p>這一塊也是很多學生會問的，如何在進入業界後持續進步。下一篇文章再分享可以參考的作法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;從 fw 工程師轉職到後端也6年了。一開始，只是因為本來的工作遇到瓶頸，又嚮往矽谷純軟公司的文化才跳出原本的圈子。&lt;/p&gt;
&lt;p&gt;這二年在 alpha camp 擔任助教，前後也指導過 4, 50位學生。&lt;/p&gt;
&lt;p&gt;每枇學生畢業前都會有一個 office hour，需要回答他們的問題及給出建議。&lt;/p&gt;
&lt;p&gt;這篇文章想整理多數轉職者的問題及自己的經驗。&lt;/p&gt;
    
    </summary>
    
    
      <category term="職涯發展" scheme="https://alexliang.me/tags/%E8%81%B7%E6%B6%AF%E7%99%BC%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka producer 如何避免 in-sync replicas fail 問題</title>
    <link href="https://alexliang.me/Kafka-producer-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-in-sync-replicas-fail-%E5%95%8F%E9%A1%8C/"/>
    <id>https://alexliang.me/Kafka-producer-如何避免-in-sync-replicas-fail-問題/</id>
    <published>2022-10-27T00:27:30.000Z</published>
    <updated>2022-10-30T05:52:26.863Z</updated>
    
    <content type="html"><![CDATA[<p>今年公司的架構開始轉為 microservice + event driven，我們選擇 <a href="https://aws.amazon.com/tw/msk/">AWS MSK</a> 託管 Kafka broker 以提供系統各 service 之間的溝通橋樑。</p><p>在一次 MSK upgrade 時，Kafka broker 重啓居然造成系統的 producer 無法 publish event，導致 streaming pipeline 短暫失常。</p><p>這篇文章記錄問題的發生原因和解決方法。</p><span id="more"></span><h2 id="Kafka-Replica"><a href="#Kafka-Replica" class="headerlink" title="Kafka Replica"></a>Kafka Replica</h2><p>在設定 Kafka broker 時，有一個參數通常會打開來，那就是 <a href="https://www.conduktor.io/kafka/kafka-topic-replication">kafka topic replication</a>。</p><p>它會複製 topic 到不同的 broker，降低一台 broker 發生問題時，event 消失的情況。</p><p>其中，replication factor 便是指定 event 會複製幾份在 broker。</p><p>假如設為 1， 表示 event 只有一份，並沒有 replication 的效果。要設幾份 replica 取決於 broker 數量及資料特性。</p><h2 id="In-Sync-Replicas-Fails"><a href="#In-Sync-Replicas-Fails" class="headerlink" title="In-Sync Replicas Fails"></a>In-Sync Replicas Fails</h2><p>假如今天 Kafka cluster 有三台 broker，replication factor 設為 2。 </p><p>在 producer publish event 時，會確保2份 replica 都寫入 broker 才回報成功。</p><p>而這次的情況是 MSK upgrade 時，重啓一台 broker，但我們的 producer 採用所有的 replica 都要寫入才算數。</p><p>這造成了不斷有 event 出現 In-Sync Replicas fails 問題，且這是無法 retry 成功的，直到 broker upgrade 完成。</p><h2 id="如何解決"><a href="#如何解決" class="headerlink" title="如何解決"></a>如何解決</h2><p>了解問題原因後，回到我們使用的 Kafka client library 官網。</p><p>找到 [produce message}(<a href="https://kafka.js.org/docs/producing#producing-messages">https://kafka.js.org/docs/producing#producing-messages</a>) 時有一個 <code>acks</code> 的選項，預設為 <code>-1</code> 表示所有 replica<br>都要完成寫入才會告知 producer publish 成功。</p><p>於是將這個參數改為 1，只要 leader broker 寫入成功便回報，這樣就能避免其中一台 broker 失效便無法完成 publish。</p><p>MSK 不定期會 upgrade，雖然都會通知用戶，但少了這個參數對系統穩定性會有很大的影響。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年公司的架構開始轉為 microservice + event driven，我們選擇 &lt;a href=&quot;https://aws.amazon.com/tw/msk/&quot;&gt;AWS MSK&lt;/a&gt; 託管 Kafka broker 以提供系統各 service 之間的溝通橋樑。&lt;/p&gt;
&lt;p&gt;在一次 MSK upgrade 時，Kafka broker 重啓居然造成系統的 producer 無法 publish event，導致 streaming pipeline 短暫失常。&lt;/p&gt;
&lt;p&gt;這篇文章記錄問題的發生原因和解決方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="kafka" scheme="https://alexliang.me/tags/kafka/"/>
    
      <category term="event-driven" scheme="https://alexliang.me/tags/event-driven/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL index 淺談及整理</title>
    <link href="https://alexliang.me/PostgreSQL-index-%E6%B7%BA%E8%AB%87%E5%8F%8A%E6%95%B4%E7%90%86/"/>
    <id>https://alexliang.me/PostgreSQL-index-淺談及整理/</id>
    <published>2022-10-16T02:48:43.000Z</published>
    <updated>2022-10-27T00:20:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子遇到了 DB 效能的問題才回頭檢視 PostgreSQL index 的基本運作和注意事項。</p><p>這篇文章簡單做個記錄，介紹 PG 是如何存放資料、為何加了 index 可以加快查詢速度，以及哪些情況用 index 沒有效果。</p><span id="more"></span><h2 id="PostgreSQL-如何存取資料"><a href="#PostgreSQL-如何存取資料" class="headerlink" title="PostgreSQL 如何存取資料"></a>PostgreSQL 如何存取資料</h2><p>資料庫做為存放 persistence data 的單元，如何設計檔案系統將資料存在 HD (SSD) 便是一大課題。</p><p>先介紹 PG 的檔案系統的各個名詞：</p><ul><li>heap file(heap): 存放 table 所有資料的檔案</li><li>item(tuple): 表示 table 的單一 row </li><li>block(page): heap file 被分為許多 block，一個 block (8KB) 包含許多 rows </li></ul><p>假如系統有一張 customers 的 table, 其內容如下:</p><p><img src="customer_table.png" alt="customer"></p><p>在沒有建 index 的情況下，使用者查詢 customers 時， PG 會將整張表載入 memory 裡再根據條件一個個找</p><p><img src="pg_heap_file_mem.drawio.png" alt="load customer table to memory"></p><p>可以想像，當這張表很多記錄時，這種操作會多麼的耗時。這也就是我們說的 full table scan</p><p><strong>note: 除了上述的情況，還有其它會造成 <a href="https://en.wikipedia.org/wiki/Full_table_scan">full table scan 的情境</a></strong></p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>為了要避免每次查詢時需要 full table scan, 我們可以選定欄位建 index</p><p>挑選欄位建 index 時，需要從查詢常用的條件下手。</p><p>PostgreSQL 提供多種 index 型態，預設使用 <a href="https://clu.gitbook.io/data-structure-note/b-tree">B tree</a> 做為 index 的資料結構</p><p>以上個例子舉例，假如塵用程式以 name 查詢 customers，以 name 建立 index 為合理的選擇。其 SQL 如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX <span class="keyword">ON</span> customers (name);</span><br></pre></td></tr></table></figure><p>建立 index 後，使用 name 查詢時，PG 會先去從 index 搜尋資料的位址:</p><p><img src="pg_heap_file_index.drawio.png" alt="index with B-Tree"></p><p>假如 SQL 為: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;ALex&#x27;</span></span><br></pre></td></tr></table></figure><p>則 PG 能從 index 知道 “Alex” 這筆記錄在 block 0, index 0 的位置。</p><h2 id="使用-Index-的限制"><a href="#使用-Index-的限制" class="headerlink" title="使用 Index 的限制"></a>使用 Index 的限制</h2><p>建完 index 後，不是每種查詢方式都能利用到它。以 <a href="https://www.postgresql.org/docs/current/indexes-types.html#INDEXES-TYPES-BTREE">B-Tree</a> 來說，它只支援 <code>&lt;   &lt;=   =   &gt;=   &gt;</code>  這幾種條件。</p><p>假如用 <code>Like</code> 這種 pattern match 的查詢，在條件是以固定字串為開始的情況，如 <code>name Like &#39;Alex%&#39;</code> 或是 <code>name Like &#39;^Alex&#39;</code> 能利用到 index。</p><p>但假如是 <code>name Like &#39;%ALex&#39;</code> 則無法利用到 index，這點要特別留意。</p><p>另外，建立 index 是需要付出代價的。它也是種存放在硬碟的檔案，隨著 table 的資料量增加，index 的用量也會增加。</p><p>在資料的 insert/update/delete 都需要更新 index，這些操作也會增加執行時間。</p><p>建議定期去整理 table 的 index，將已經沒有使用的 index 刪掉。 </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.udemy.com/course/sql-and-postgresql/">SQL and PostgreSQL: The Complete Developer’s Guide</a></li><li><a href="https://www.postgresql.org/docs/current/indexes-types.html#INDEXES-TYPES-BTREE">B-Tree Index Type</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前陣子遇到了 DB 效能的問題才回頭檢視 PostgreSQL index 的基本運作和注意事項。&lt;/p&gt;
&lt;p&gt;這篇文章簡單做個記錄，介紹 PG 是如何存放資料、為何加了 index 可以加快查詢速度，以及哪些情況用 index 沒有效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="postgresql" scheme="https://alexliang.me/tags/postgresql/"/>
    
      <category term="database" scheme="https://alexliang.me/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>使用 babel decorator plugin 實現 Aspect-Oriented Programming</title>
    <link href="https://alexliang.me/%E4%BD%BF%E7%94%A8-babel-decorator-plugin-%E5%AF%A6%E7%8F%BE-Aspect-Oriented-Programming/"/>
    <id>https://alexliang.me/使用-babel-decorator-plugin-實現-Aspect-Oriented-Programming/</id>
    <published>2022-09-03T08:15:27.000Z</published>
    <updated>2022-09-10T14:09:21.357Z</updated>
    
    <content type="html"><![CDATA[<p>實務上經常會遇到程式流程夾雜許多非核心，但又必須得做的行為，例如 logging, auit, notification 或 cache.</p><p>這篇文章介紹如何使用 babel decorator plugin 實現 Aspect Object Programming。</p><p>將共用的功能抽到 decorator，讓整個流程變的清楚好懂。<br><span id="more"></span></p><p>開頭提到的這些行為在不同實作間會一直重複發生。對於想了解流程的人來說，這些其實不是核心的部分，如下圖所示：</p><p><img src="aspect-oriented-programming.jpeg" alt="aspect-oriented-programming"></p><p>note: <em>在 SRE 的世界同樣也會發生每個 container 需要加入非業務邏輯的功能，如提供 HTTPS。其解決方案是 <a href="https://tachingchen.com/tw/blog/desigining-distributed-systems-the-sidecar-pattern-concept/">https://tachingchen.com/tw/blog/desigining-distributed-systems-the-sidecar-pattern-concept/</a> 稱為 sidecar pattern</em></p><h2 id="Babel-Decorator-Plugin"><a href="#Babel-Decorator-Plugin" class="headerlink" title="Babel Decorator Plugin"></a>Babel Decorator Plugin</h2><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p><strong>在安裝 babel plugin 前，請先確保已安裝 @babel/core and @babel/preset-env</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-proposal-decorators @babel/eslint-parser</span><br></pre></td></tr></table></figure><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>設定 babel config: </p><figure class="highlight javascript"><figcaption><span>babel.config.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/plugin-proposal-decorators&quot;</span>, &#123; <span class="attr">legacy</span>: <span class="literal">true</span> &#125;]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">presets</span>: [</span><br><span class="line">    [<span class="string">&quot;@babel/preset-env&quot;</span>, &#123; <span class="attr">targets</span>: &#123; <span class="attr">node</span>: <span class="string">&quot;current&quot;</span> &#125; &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果專案有使用 ESLint，需要設定 parser 讓 ESLint 認得 decorator</p><figure class="highlight javascript"><figcaption><span>.eslint.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">parser</span>: <span class="string">&quot;@babel/eslint-parser&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>我們以 log 為例，babel decorator 本筫上是一個 wrapper function。其 signature 為 <code>(value, context)</code></p><p><code>value</code> 就是包裝的對象，可以是 function 或 class，使用 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">apply</a> 取得對象的結果。</p><p>如此一來，我們可以選擇在包裝對象的前後插入程式碼，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">value, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123; <span class="comment">// args is arguments of wrapped method</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Logged at: &quot;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString());</span><br><span class="line">    <span class="keyword">return</span> value.apply(<span class="built_in">this</span>, args);  <span class="comment">// value is wrapped method</span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @log</span><br><span class="line">  <span class="function"><span class="title">getBio</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is a <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這裡宣告 log decorator，能印出呼叫對象的時間點及 error handling。</p><p>另一個需要注意的是 <code>context</code> 參數，它是一個 object 具有包裝對象的資訊。我們可以到 <a href="https://javascriptdecorators.org/">decorator playground</a> 試玩，可以發現 <code>context</code> 有以下 property:</p><ul><li>kind</li><li>name</li><li>isStatic</li><li>isPrivate</li><li>getMetadata</li><li>setMetadata</li></ul><p>常用的有 <code>kind</code> 和 <code>name</code>，前者為包裝對象的類型，在這個範例為 <code>method</code>；後者為對象的名稱。</p><p>這些資訊能讓 decorator 做更有彈性的處理，例如針對  class 的 decorator。</p><p>需要注意的是，假如 decorator 對象是 static method，則包裝後的 method 也會是 static。</p><blockquote><p>note: babel 最近 release <a href="https://babeljs.io/blog/2022/09/05/7.19.0#stage-3-decorators-14836httpsgithubcombabelbabelpull14836">Stage 3 decorators</a>，其 <code>context</code> 有些許差異，使用上需多做留意。</p></blockquote><p>我們也可以給予 decorator 參數，讓行為有更多變化，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cached</span>(<span class="params">key</span>) =&gt; (<span class="params">value, context</span>) =&gt; </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (map.has(key)) <span class="keyword">return</span> map.get(key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = value.apply(<span class="built_in">this</span>, args);</span><br><span class="line">map.set(key, result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  @cached(KEY)</span><br><span class="line">  <span class="keyword">get</span> <span class="title">amount</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.logrocket.com/understanding-javascript-decorators/">https://blog.logrocket.com/understanding-javascript-decorators/</a></li><li><a href="https://docs.nestjs.com/interceptors">https://docs.nestjs.com/interceptors</a></li><li><a href="https://docs.typestack.community/typedi/02-basic-usage-guide">https://docs.typestack.community/typedi/02-basic-usage-guide</a></li><li><a href="https://tsed.io/docs/interceptors.html#interceptor-class">https://tsed.io/docs/interceptors.html#interceptor-class</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;實務上經常會遇到程式流程夾雜許多非核心，但又必須得做的行為，例如 logging, auit, notification 或 cache.&lt;/p&gt;
&lt;p&gt;這篇文章介紹如何使用 babel decorator plugin 實現 Aspect Object Programming。&lt;/p&gt;
&lt;p&gt;將共用的功能抽到 decorator，讓整個流程變的清楚好懂。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://alexliang.me/tags/javascript/"/>
    
      <category term="babel" scheme="https://alexliang.me/tags/babel/"/>
    
      <category term="aop" scheme="https://alexliang.me/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>[Working with legacy code] 使用 newman 建立整合測試</title>
    <link href="https://alexliang.me/Working-with-legacy-code-%E4%BD%BF%E7%94%A8-newman-%E5%BB%BA%E7%AB%8B%E6%95%B4%E5%90%88%E6%B8%AC%E8%A9%A6/"/>
    <id>https://alexliang.me/Working-with-legacy-code-使用-newman-建立整合測試/</id>
    <published>2021-09-12T03:05:27.000Z</published>
    <updated>2021-09-12T06:17:46.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>這陣子開始重構公司的 legacy code，應該說是porting到新的repo。但舊專案有個很大的問題: <strong>沒寫測試</strong>。</p><p>這讓重構增加一些不確定性。還好，這些 API 都有經過 QA 測試。</p><p>我們需要寫 API integration test。但在時程壓力下，有沒有方法不需要寫 test code 去檢驗 porting 的 API 呢？</p><span id="more"></span><p>於是就有了這篇文章，說明如何使用 <a href="https://www.getpostman.com/">postman</a> 和 npm package <a href="https://www.npmjs.com/package/newman">newman</a> 完成這個任務。</p><h2 id="作法"><a href="#作法" class="headerlink" title="作法"></a>作法</h2><ol><li>在 postman 建立新的 collection <img src="create-new-collection.png" alt="create new collection"></li><li>建立新的 request，填好 request 所需要的參數。這裡會以公司的dev環境為主 <img src="create-new-request.png" alt="create new request"></li><li><p>send request。得到正確的 response 後，這裡有二種作法:</p><ul><li>使用 <a href="https://autotester.softwareontheroad.com/">https://autotester.softwareontheroad.com/</a>。它會幫你產出 postman 的測項，將它貼在 postman 的 Tests</li><li><p>使用 <a href="https://jsonschema.net/home">https://jsonschema.net/home</a> 。它會產出 schema，在 postman 的 Pre-request Script 貼上 <code>schema = [產出的 schema]</code>，並且在 Tests 加上 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  pm.test(&quot;Validating is API schema correct&quot;, function() &#123;</span><br><span class="line">    var response = pm.response.json();</span><br><span class="line">    console.log(response);</span><br><span class="line">    var result=tv4.validateResult(response, schema)</span><br><span class="line">    pm.expect(result.valid).to.be.true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>cauiion: 上述二個網站雖然只貼上response，如果有敏感的資料還是要謹慎使用</strong></p></li></ul></li><li>完成後，儲存 request 和 collection 並 export json </li><li>在 nodejs project 安裝 newman <code>npm install -g newman</code> </li><li>新增測試檔案，並且將剛才 export 的 json file移到同一個目錄</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const newman = require(&#x27;newman&#x27;)</span><br><span class="line">newman.run(&#123;</span><br><span class="line">  collection: require(&#x27;./APIContractTest.postman_collection.json&#x27;),</span><br><span class="line">  reporters: &#x27;cli&#x27;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p> 到這裡，已經可以針對各 API 做 integration test。不需要寫code，也不用怕改壞 API。</p><p> 如果在本地端準備好測試資料的 seeder，還能進一步結合 CI/CD 讓測試可以自動化。之後工程師也可以安心地重構程式碼。</p><p>references:</p><ul><li><a href="https://softwareontheroad.com/simple-end-to-end-testing-node/">Practical but powerful way to test Node.js APIs without hassle</a></li><li><a href="https://medium.com/@gururajhm/contract-api-testing-with-postman-node-js-express-newman-d91f3cd51fd4">Contract API testing with Postman, Node.js, Express, Newman</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h2&gt;&lt;p&gt;這陣子開始重構公司的 legacy code，應該說是porting到新的repo。但舊專案有個很大的問題: &lt;strong&gt;沒寫測試&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;這讓重構增加一些不確定性。還好，這些 API 都有經過 QA 測試。&lt;/p&gt;
&lt;p&gt;我們需要寫 API integration test。但在時程壓力下，有沒有方法不需要寫 test code 去檢驗 porting 的 API 呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://alexliang.me/tags/Node-js/"/>
    
      <category term="newman" scheme="https://alexliang.me/tags/newman/"/>
    
      <category term="postman" scheme="https://alexliang.me/tags/postman/"/>
    
      <category term="integration test" scheme="https://alexliang.me/tags/integration-test/"/>
    
  </entry>
  
  <entry>
    <title>[Design Pattern] 利用dependency injection降低耦合</title>
    <link href="https://alexliang.me/Design-Pattern-%E5%88%A9%E7%94%A8dependency-injection%E9%99%8D%E4%BD%8E%E8%80%A6%E5%90%88/"/>
    <id>https://alexliang.me/Design-Pattern-利用dependency-injection降低耦合/</id>
    <published>2021-03-14T02:23:38.000Z</published>
    <updated>2021-03-14T12:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://alexliang.me/Design-Pattern-工廠方法模式-Factory-介紹與應用/">前一篇文章</a>介紹如何使用工廠方法。本篇介紹另一種技巧能切開商業邏輯和資料存取的程式碼。</p><span id="more"></span><p>以之前電商平台的物流系統為例，假如此專案是外包的需求，A客戶指定用MySQL;而B客戶習慣PostgreSQL。在實作部分一開始為：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const db = require(&#x27;./db&#x27;);</span><br><span class="line"></span><br><span class="line">// 宣告超商取貨</span><br><span class="line">class ConvenienceStoreDelivery : Delivery &#123;</span><br><span class="line">   constructor(shipAddress) &#123;</span><br><span class="line">     // 略</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> get shippingRate() &#123; </span><br><span class="line">return (async() =&gt; </span><br><span class="line">db.query(&#x27;SELECT rate FROM tbl_shipment_info WHERE type = convenience_store&#x27;);  </span><br><span class="line">)(); </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  get freeShipmentThreshold() &#123;</span><br><span class="line">    return (async() =&gt; </span><br><span class="line">    db.query(&#x27;SELECT free_shipment_threshold FROM tbl_shipment_info WHERE type = convenience_store&#x27;);</span><br><span class="line">    )();     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上例中，我們依賴 db 這個檔案建立連線和設定。而這也帶來缺點: 寫測試時必須依賴實體的 database、不同的實作要使用另一個連線時要給額外的參數。</p><p>此時可以應用 dependency injection。在 Node.js 裡有三種方式可以達成</p><ol><li>constructor</li><li>setter</li><li>bind</li></ol><p>本文使用 constructor 當範例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class ConvenienceStoreDelivery : Delivery &#123;</span><br><span class="line">   constructor(shipAddress, db) &#123;</span><br><span class="line">     this.db = db;</span><br><span class="line">     this.shipAddress = shipAddress;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> get shippingRate() &#123; </span><br><span class="line">return (async() =&gt; </span><br><span class="line">this.db.query(&#x27;SELECT rate FROM tbl_shipment_info WHERE type = convenience_store&#x27;);  </span><br><span class="line">)(); </span><br><span class="line"> &#125;</span><br><span class="line">  </span><br><span class="line">  get freeShipmentThreshold() &#123;</span><br><span class="line">    return (async() =&gt; </span><br><span class="line">    this.db.query(&#x27;SELECT free_shipment_threshold FROM tbl_shipment_info WHERE type = convenience_store&#x27;);</span><br><span class="line">    )();     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// database.js</span><br><span class="line">class Database &#123;</span><br><span class="line">  constructor(config) &#123;</span><br><span class="line">     this._config = config;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  connect() &#123; // connect db &#125;</span><br><span class="line">  </span><br><span class="line">  query() &#123; // 略 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// config.js</span><br><span class="line">const config = &#123;</span><br><span class="line">  MYSQL_CONFIG: &#123;</span><br><span class="line">    server: process.env.DB_SERVER,</span><br><span class="line">    database: process.env.DB_NAME,</span><br><span class="line">    user: process.env.DB_USER,</span><br><span class="line">    password: process.env.DB_PW</span><br><span class="line">  &#125;,</span><br><span class="line">  POSTGRES_CONFIG: &#123;</span><br><span class="line">    // 略</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用戶端</span><br><span class="line">const config = require(&#x27;./config&#x27;);</span><br><span class="line">const Database = require(&#x27;./database&#x27;);</span><br><span class="line"></span><br><span class="line">const db = new Database(config.MYSQL_CONFIG);</span><br><span class="line">db.connect();</span><br><span class="line"></span><br><span class="line">const factory = new ConvenienceStoreDeliveryFactory();</span><br><span class="line">const convenienceStoreDelivery = factory.createDeliveryService(shipAddress, db);</span><br></pre></td></tr></table></figure><p>這樣就能把 database 和實作隔開，如果專案要換其它的 db，只要改設定值 (或用環境變數) 即可。<br>應用此技巧能把二個不必要的耦合分開來，讓之後的修改更有彈性，<a href="https://nestjs.com/">nest.js</a>也採用這種方式設計框架。</p><p>ref: <a href="https://medium.com/@magnusjt/dependency-injection-in-nodejs-9601a19c1f36">Dependency Injection in nodejs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://alexliang.me/Design-Pattern-工廠方法模式-Factory-介紹與應用/&quot;&gt;前一篇文章&lt;/a&gt;介紹如何使用工廠方法。本篇介紹另一種技巧能切開商業邏輯和資料存取的程式碼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://alexliang.me/tags/Node-js/"/>
    
      <category term="design pattern" scheme="https://alexliang.me/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>[Design Pattern] 工廠方法模式(Factory)介紹與應用</title>
    <link href="https://alexliang.me/Design-Pattern-%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Factory-%E4%BB%8B%E7%B4%B9%E8%88%87%E6%87%89%E7%94%A8/"/>
    <id>https://alexliang.me/Design-Pattern-工廠方法模式-Factory-介紹與應用/</id>
    <published>2021-02-28T01:35:15.000Z</published>
    <updated>2021-03-14T02:42:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://alexliang.me/Design-Pattern-簡單工廠方法模式-Simple-Factory-介紹與應用/">上一篇</a>講到簡單工廠方法，這篇文章介紹它的延申: 工廠方法</p><span id="more"></span><h3 id="適合場景"><a href="#適合場景" class="headerlink" title="適合場景"></a>適合場景</h3><p>有二個以上、功能相近但細節稍有不同的資料結構或實作，且隨著業務增長會不斷增加實作的情況。例如本來只服務台灣的電商平台，需要擴展到海外，其寄送方式和服務商會大幅增加。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>一樣以電商的物流為例，如何使用工廠模式解決不斷增加的寄送方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告基本的物流類別</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delivery</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.shipAddress = shipAddress;</span><br><span class="line">     <span class="built_in">this</span>.shippingRate = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">this</span>.freeShipmentThreshold = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.traceNumber = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">get</span> <span class="title">shippingRate</span>() &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.shippingRate; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">freeShipmentThreshold</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.freeShipmentThreshold;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">set</span> <span class="title">traceNumber</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">get</span> <span class="title">traceNumber</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.traceNumber;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 宣告超商取貨</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ConvenienceStoreDelivery</span> : <span class="title">Delivery</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.shipAddress = shipAddress;</span><br><span class="line">       <span class="built_in">this</span>.shippingRate = <span class="number">100</span>;</span><br><span class="line">       <span class="built_in">this</span>.freeShipmentThreshold = <span class="number">2000</span>;</span><br><span class="line">      <span class="built_in">this</span>.traceNumber = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title">traceNumber</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 宣告郵局寄送</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PostOfficeDelivery</span> : <span class="title">Delivery</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="title">constructor</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.shipAddress = shipAddress;</span><br><span class="line">        <span class="built_in">this</span>.shippingRate = <span class="number">80</span>;</span><br><span class="line">        <span class="built_in">this</span>.freeShipmentThreshold = <span class="number">1000</span>;</span><br><span class="line">       <span class="built_in">this</span>.traceNumber = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">           </span><br><span class="line">     <span class="keyword">set</span> <span class="title">traceNumber</span>() &#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>宣告各物流服務後，接下來是建立工廠類別介面和實作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告工廠類別介面</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDeliveryFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">createDeliveryService</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Implement me!&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 宣告超商取貨工廠</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConvenienceStoreDeliveryFactory</span> : <span class="title">IDeliveryFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">createDeliveryService</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ConvenienceStoreDelivery(shipAddress);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 宣告郵局寄送工廠</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">PostOfficeDeliveryFactory</span> : <span class="title">IDeliveryFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">createDeliveryService</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> PostOfficeDelivery(shipAddress);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>用戶端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果要換其它物流方式，修改這裡即可</span></span><br><span class="line"><span class="keyword">const</span> factory = <span class="keyword">new</span> ConvenienceStoreDeliveryFactory();</span><br><span class="line"><span class="keyword">const</span> convenienceStoreDelivery = factory.createDeliveryService(shipAddress);</span><br></pre></td></tr></table></figure><p>乍看之下多了不少程式碼，但工廠方法的優點在於新增實作不會違反開放-封閉原則，不用每次都要修改switch case，將判斷拉到用戶端。 </p><h3 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h3><ul><li>不建議一開始就使用工廠方法，也許簡單工廠方法就能應付，等到業務需求大增再改就好</li><li>此方法對用戶端有額外的判斷，若太多用戶端都需要使用會造成負擔，要靠其它方法解決</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://alexliang.me/Design-Pattern-簡單工廠方法模式-Simple-Factory-介紹與應用/&quot;&gt;上一篇&lt;/a&gt;講到簡單工廠方法，這篇文章介紹它的延申: 工廠方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="design pattern" scheme="https://alexliang.me/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>[商業思維學院] Ant-技術人的職涯規劃心得</title>
    <link href="https://alexliang.me/%E5%95%86%E6%A5%AD%E6%80%9D%E7%B6%AD%E5%AD%B8%E9%99%A2-%E6%8A%80%E8%A1%93%E4%BA%BA%E7%9A%84%E8%81%B7%E6%B6%AF%E8%A6%8F%E5%8A%83%E5%BF%83%E5%BE%97/"/>
    <id>https://alexliang.me/商業思維學院-技術人的職涯規劃心得/</id>
    <published>2021-02-07T14:19:19.000Z</published>
    <updated>2021-02-08T14:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>週四參加商業思維學院的線上講座，𨘋請到<a href="https://www.facebook.com/yftzeng.tw">Ant 曾義峰</a>分享技術人的職涯規劃。Ant是我有在追蹤的技術人，對於這位橫跨技術、法律、資安和商業的高手只有敬佩。</p><span id="more"></span><p>管理職 vs. 技術職一直是技術人熱衷討論的話題。在台灣，大多數公司給予管理職較高的薪水和權責。但某些技術人對於管理團隊又興趣缺缺，深怕自己的技術力不斷退步而被時代淘汰。</p><p>Ant提出一個概念: <code>升遷體系 不等於 職涯發展</code>。升遷體系隨著外在環境變化；而職涯發展要配適內在自我</p><p>不同於要求技術工作者一路往公司的階梯上爬，這個框架是同時注意外在和內在的發展。在獲得升遷、加薪的同時，也要顧好成就感及發揮最大潛力。對技術人來說，最浪費的莫過於給予高薪但被放在無法發揮實力的地方，這也是Ant要大家關注的點。</p><p>演講中最讓我受到啟發的是Ant把技術職和管理職視為二個互為關聯的階梯。你不必一直在單一軌道往上爬，而是能夠在二者之間轉換。對於職涯規劃來說是更靈活的手段和方法。</p><p>接下來Ant說明如何避免技術人最害怕的事: <code>跟不上新技術、手中的工具已經落伍了。</code></p><p>這裡的心法我覺得和Amazon的Jeff Bazos在2012年re.invent大會所講的話類似:</p><blockquote><p>我常被問一個問題：「在接下來的10年裡，會有什麼樣的變化？」……但我很少被問到「在接下來的10年裡，什麼是不變的？」我認為第二個問題比第一個問題更加重要，因為你需要將你的戰略建立在不變的事物上。</p></blockquote><p>在軟體開發來說，不變的事物便是design pattern, refactor和其它各種新技術底層的理論。像最近幾年引領AI的深度學習，其底層是1980年代就出現的類神經網路，只不過當時的環境和技術沒辦法有突破性的應用。</p><p>這幾年下來有一個體會，當程式語言或碰過的技術到一定的程度時，你能辨識出它設計的哲學及適合的場景。將來用到類似的新工具時，能很快上手並且知道它的限制。</p><p>從OOP的角度來看，我們關注的是全局及結構；而不是細節。對於新技術/工具，能儘快掌握特性和應用場景才是技術人生存之道。</p><p>Ant也分享幾個面試可以請教對方的問題，例如:</p><ul><li>最近離職者離開的原因？開除員工的原因？</li><li>最近的升遷/加薪情況，週期/幅度</li><li>測試覆蓋率、流程自動化和指導文化</li></ul><p>還有一個take away question: </p><blockquote><p>如果有人拿一百萬鎂請你組一個團隊，在一年內推出產品，你有這個能力嗎？ 或是說你該如何做到？ </p></blockquote><p>這是一個很棒的練習，讓我們思考自己在業界的高度和人脈是否達到一個水準。</p><p>最後，我在QA時問了一題： 如果嚮往的工作有某項條件/經驗(例如碰過 DAU &gt; 100K的系統)，面試時該怎麼回答？ 老師給的答案是: 可以先問做過的人，並且在面試時誠實說出，重點是讓對方感受到自己是能解決問題的人。</p><p>期許自己也能成為厲害的技術人</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;週四參加商業思維學院的線上講座，𨘋請到&lt;a href=&quot;https://www.facebook.com/yftzeng.tw&quot;&gt;Ant 曾義峰&lt;/a&gt;分享技術人的職涯規劃。Ant是我有在追蹤的技術人，對於這位橫跨技術、法律、資安和商業的高手只有敬佩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="演講筆記" scheme="https://alexliang.me/tags/%E6%BC%94%E8%AC%9B%E7%AD%86%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>[Design Pattern] 簡單工廠方法模式(Simple Factory)介紹與應用 </title>
    <link href="https://alexliang.me/Design-Pattern-%E7%B0%A1%E5%96%AE%E5%B7%A5%E5%BB%A0%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Simple-Factory-%E4%BB%8B%E7%B4%B9%E8%88%87%E6%87%89%E7%94%A8/"/>
    <id>https://alexliang.me/Design-Pattern-簡單工廠方法模式-Simple-Factory-介紹與應用/</id>
    <published>2020-10-26T13:38:16.000Z</published>
    <updated>2021-02-28T01:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近重溫<a href="https://www.tenlong.com.tw/products/9789866761799">大話設計模式</a>，對各個design pattern有更深的了解，試著介紹常用的幾種模式並說明適合的場景。</p><p>第一篇要介紹的是簡單工廠方法模式。</p><span id="more"></span><h3 id="適合場景"><a href="#適合場景" class="headerlink" title="適合場景"></a>適合場景</h3><p>有二個以上、功能相近但細節稍有不同的資料結構或實作，適合用簡單工廠方法模式。如薪資計算(正職、工讀生)、電商平台的寄件方式(宅急便、超商或郵局)。</p><p>以電商平台的寄件舉例，其共通的屬性有: </p><ol><li>收件地址 (一般地址/超商門市)</li><li>運費</li><li>免運門檻</li><li>物流追蹤碼</li></ol><p>若平台增加新的寄件方式，專案中有關寄件的程式碼都要新增條件才能避免錯誤。</p><h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ConvenienceStoreDelivery</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">shipAddress</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.shipAddress = shipAddress;</span><br><span class="line">      <span class="built_in">this</span>.shippingRate = <span class="number">100</span>;</span><br><span class="line">      <span class="built_in">this</span>.freeShipmentThreshold = <span class="number">2000</span>;</span><br><span class="line">    <span class="built_in">this</span>.traceNumber = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title">shippingRate</span>() &#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.shippingRate; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">get</span> <span class="title">freeShipmentThreshold</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.freeShipmentThreshold;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">set</span> <span class="title">traceNumber</span>() &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">get</span> <span class="title">traceNumber</span>() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">this</span>.traceNumber;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">DeliveryFactory</span>(<span class="params">provider, address</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> deliveryProvider = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (provider) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;convenience store&#x27;</span>:</span><br><span class="line">        deliveryProvider = <span class="keyword">new</span> ConvenienceStoreDelivery(address);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;post office&#x27;</span></span><br><span class="line">        deliveryProvider = <span class="keyword">new</span> PostOfficeDelivery(address);  </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Cannot recongize delivery provider <span class="subst">$&#123;provider&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> deliveryProvider</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用戶端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> deliveryProvider = DeliveryFactory(provider, address);</span><br><span class="line"><span class="comment">// 其餘操作</span></span><br></pre></td></tr></table></figure><h3 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h3><ul><li>假如實作端會隨著業務、流程不斷增加數量，則此方法每新增實作類別就必須增加case的分支。這會破壞開放-封閉原則。此時可考慮改用工廠方法 </li><li>此方法只針對物件建立問題，若實作類別的函式經常更動(如免運、折價)，可考慮使用策略模式封裝實作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近重溫&lt;a href=&quot;https://www.tenlong.com.tw/products/9789866761799&quot;&gt;大話設計模式&lt;/a&gt;，對各個design pattern有更深的了解，試著介紹常用的幾種模式並說明適合的場景。&lt;/p&gt;
&lt;p&gt;第一篇要介紹的是簡單工廠方法模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="design pattern" scheme="https://alexliang.me/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS使用ESM Import載入模組</title>
    <link href="https://alexliang.me/NodeJS%E4%BD%BF%E7%94%A8ESM-Import%E8%BC%89%E5%85%A5%E6%A8%A1%E7%B5%84/"/>
    <id>https://alexliang.me/NodeJS使用ESM-Import載入模組/</id>
    <published>2020-07-05T13:26:48.000Z</published>
    <updated>2020-09-21T13:11:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://alexliang.me/NodeJS-%E8%A7%A3%E6%B1%BArequire%E7%9B%B8%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%95%8F%E9%A1%8C/">上一篇</a>介紹如何解決CommonJS相對路徑問題。假如你偏好ES6的export/import，從NodeJS 12開始支援實驗性質的解決方法。</p><!-- more  --><p>二個地方需要修改:</p><ol><li>package.json 加入 <code>&quot;type&quot;: &quot;module&quot;</code></li><li>執行程式時加入 <code>--experimental-modules</code> 或修改package.json的start script</li></ol><p>以上是不用修改副檔名的方式，否則NodeJS預設只認<code>.mjs</code>的檔案能使用export/import</p><p>接下來介紹 export/import 的基本語法</p><p>有二種 export 方式: <strong>named</strong> 和 <strong>default</strong>, 一個檔案可以有許多 named export, 但只能有一個 default export</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 named export</span></span><br><span class="line"><span class="keyword">export</span> funcA = <span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">Math</span>.sqrt(val);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> seed = <span class="built_in">Math</span>.random();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 default export, 注意結尾不加分號</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>named export 會強制使用同樣的名稱 import, 而 default export 可用任意名稱輸入, 例如:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str = <span class="string">&#x27;default&#x27;</span>; <span class="comment">// module1.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./module1&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.info(a); <span class="comment">// &#x27;default&#x27;</span></span><br></pre></td></tr></table></figure></p><p>如果一個檔案有許多 named export, 如果要選擇部分物件, 則:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant.js</span></span><br><span class="line"><span class="keyword">export</span> VALID_TYPES = [...];</span><br><span class="line"><span class="keyword">export</span> VALID_STATUS = [...];</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js, 只輸入 VALID_TYPES</span></span><br><span class="line"><span class="keyword">import</span> &#123; VALID_TYPES &#125; <span class="keyword">from</span> <span class="string">&#x27;./constant&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app2.js, 將 VALID_STATUS 改名</span></span><br><span class="line"><span class="keyword">import</span> &#123; VALID_STATUS <span class="keyword">as</span> ALERT_STATUS &#125; <span class="keyword">from</span> <span class="string">&#x27;./constant&#x27;</span></span><br></pre></td></tr></table></figure><p>reference:</p><ol><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/import">import document</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/export">export document</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://alexliang.me/NodeJS-%E8%A7%A3%E6%B1%BArequire%E7%9B%B8%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%95%8F%E9%A1%8C/&quot;&gt;上一篇&lt;/a&gt;介紹如何解決Commo
      
    
    </summary>
    
    
      <category term="Node.js" scheme="https://alexliang.me/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS 解決require相對路徑問題</title>
    <link href="https://alexliang.me/NodeJS-%E8%A7%A3%E6%B1%BArequire%E7%9B%B8%E5%B0%8D%E8%B7%AF%E5%BE%91%E5%95%8F%E9%A1%8C/"/>
    <id>https://alexliang.me/NodeJS-解決require相對路徑問題/</id>
    <published>2020-06-14T11:35:02.000Z</published>
    <updated>2020-06-14T12:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node.JS目前有二種方式載入module: CommonJS(也就是本文會介紹的方式)及<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/import">ES6的import/export</a>。</p><p>CommonJS是預設的module載入方式，其使用方式為 require &amp; module.exports</p><figure class="highlight javascript"><figcaption><span>funcA.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = funcA;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> funcA = <span class="built_in">require</span>(<span class="string">&#x27;funcA&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  funcA();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信大家對此都不陌生，然而此方法最大的問題是module如果是專案的source file，其require的路徑為相對路徑。假如專案結構有許多階層，在使用上會相當不便</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|- src</span><br><span class="line">|--utils</span><br><span class="line">|---moduleA.js</span><br><span class="line">|--routes</span><br><span class="line">|---v1</span><br><span class="line">|----admin</span><br><span class="line">|-----singIn.js</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singIn.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;../../../utils/moduleA&#x27;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>今天介紹在npm script使用symlink解決此問題</p><p>在package.json 加入 <code>&quot;postinstall&quot; : &quot;node -e \&quot;var s=&#39;../src&#39;,d=&#39;node_modules/src&#39;,fs=require(&#39;fs&#39;);fs.exists(d,function(e)&#123;e||fs.symlinkSync(s,d,&#39;dir&#39;)&#125;);\&quot;&quot;</code>並且 npm install</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singIn.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;src/utils/moduleA&#x27;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>是不是好看很多？</p><p>此方法建立一個symlink連結到專案的source folder，讓CommonJS在node_module下找到要載入的module</p><p>但是這樣設定有另一個副作用，如果專案有裝eslint的話，它會跳出<a href="https://github.com/benmosher/eslint-plugin-import/blob/v2.21.2/docs/rules/no-extraneous-dependencies.md">import/no-extraneous-dependencies</a>的錯誤。eslint預設禁止載入不在package.json的dependencies, devDependencies,  optionalDependencies, peerDependencies或bundledDependencies的模組</p><p>如果想忽略此警告，在.eslintrc加上 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;rules&quot;: &#123;</span><br><span class="line">    &quot;import/no-extraneous-dependencies&quot;: [0]</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上是修正require不能使用絕對路徑的問題，如果覺得此方式太hack，下一篇介紹import/export來載入module</p><p>參考資料: <a href="https://gist.github.com/branneman/8048520#3-the-module">Better local require() paths for Node.js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.JS目前有二種方式載入module: CommonJS(也就是本文會介紹的方式)及&lt;a href=&quot;https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/import&quot;&gt;ES6的import/export&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;CommonJS是預設的module載入方式，其使用方式為 require &amp;amp; module.exports&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaption&gt;&lt;span&gt;funcA.js&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;funcA&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = funcA;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;figcaption&gt;&lt;span&gt;index.js&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; funcA = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;funcA&amp;#x27;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  funcA();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;相信大家對此都不陌生，然而此方法最大的問題是module如果是專案的source file，其require的路徑為相對路徑。假如專案結構有許多階層，在使用上會相當不便&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://alexliang.me/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>使用ELK監控MongoDB service</title>
    <link href="https://alexliang.me/%E4%BD%BF%E7%94%A8ELK%E7%9B%A3%E6%8E%A7MongoDB-service/"/>
    <id>https://alexliang.me/使用ELK監控MongoDB-service/</id>
    <published>2019-01-31T03:26:14.000Z</published>
    <updated>2019-02-16T09:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://alexliang.me/使用ELK-Metricbeat收集MongoDB-Log">上一篇</a>提到如何安裝ELK和Metricbeat收集DB的log，接下來介紹如何在Kibana設定watcher讓系統有問題時自動通知管理者。</p><span id="more"></span><h2 id="設定Watcher"><a href="#設定Watcher" class="headerlink" title="設定Watcher"></a>設定Watcher</h2><p>進入SENTINL的頁面，在右上角點選<code>New</code>新增watcher</p><p><img src="sentinl_setting.png" alt="sentinl_setting"></p><p>使用watcher wizard設定watcher的名稱和使用的index</p><p><img src="watcher_wizard.png" alt="watcher_wizard"></p><p>設定完可以看到下方出現折線圖</p><p><img src="chart.png" alt="chart"></p><p>可以針對內建指標做監控並設定觸發條件。</p><p>接下來是設定通知的動作，這裡以email為例，可設定寄件人(也就是在<code>kibana.yml</code>設定的user email)和收件人及訊息內容</p><p><img src="action.png" alt="action"></p><h2 id="設定特殊條件的Watcher"><a href="#設定特殊條件的Watcher" class="headerlink" title="設定特殊條件的Watcher"></a>設定特殊條件的Watcher</h2><p>當你要監控的指標需要自行計算時(如磯碟己用空間的百分比，該數值在dashboard是由磁碟空間和己用空間計算出來)便需要自行修改query語法</p><p>我們使用wizard新增watcher，<strong>WHEN</strong>選擇max，此時可看到<strong>AGG</strong>多了一個field，選擇<code>system.ffstat.total_size.total</code></p><p><img src="system_total.png" alt="system_total"></p><p>點選<strong>Watcher Query</strong>，然後conver to advanced，開始修改query條件。此時畫面會回到watcher清單，再點選剛才建立的watcher，會發現看到類似DSL語法的畫面</p><p>在<code>metricAgg</code>下可看到剛才設定的<code>system.ffstat.total_size.total</code>。我們新增一項指標並修改<code>condition</code>的script在磁碟空間己用80%時發通知</p><p><img src="advanced_watcher.png" alt="advanced_watcher"></p><p>修改後別忘了儲存，可以回到watcher清單列表，在<strong>Alarms</strong>可以看到通知有無正確的發出。</p><p>這個機制可用在其它後端服務上，對於管理機器是個方便的工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://alexliang.me/使用ELK-Metricbeat收集MongoDB-Log&quot;&gt;上一篇&lt;/a&gt;提到如何安裝ELK和Metricbeat收集DB的log，接下來介紹如何在Kibana設定watcher讓系統有問題時自動通知管理者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="devops" scheme="https://alexliang.me/tags/devops/"/>
    
      <category term="mongodb" scheme="https://alexliang.me/tags/mongodb/"/>
    
      <category term="ELK" scheme="https://alexliang.me/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>使用ELK + Metricbeat收集MongoDB Log</title>
    <link href="https://alexliang.me/%E4%BD%BF%E7%94%A8ELK%20+%20Metricbeat%E6%94%B6%E9%9B%86MongoDB%20Log/"/>
    <id>https://alexliang.me/使用ELK + Metricbeat收集MongoDB Log/</id>
    <published>2019-01-26T08:14:12.000Z</published>
    <updated>2019-02-16T09:52:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究如何使用ELK(Elasticsearch, Logstash和Kibana)監控MongoDB的效能，之前公司己經使用ELK監控爬蟲，這次試著擴大範圍並加入告警的通知。<br><span id="more"></span></p><h2 id="安裝ELK"><a href="#安裝ELK" class="headerlink" title="安裝ELK"></a>安裝ELK</h2><p>我們使用<a href="https://github.com/deviantony/docker-elk">docker-elk</a>安裝ELK stack</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:deviantony/docker-elk.git</span><br></pre></td></tr></table></figure><h2 id="安裝SENTINL-Plugin"><a href="#安裝SENTINL-Plugin" class="headerlink" title="安裝SENTINL Plugin"></a>安裝SENTINL Plugin</h2><p>Kibana需要安裝<a href="https://sentinl.readthedocs.io/en/latest/">SENTINL</a>這套plugin才能加上watcher的功能</p><p>修改kibana資料夾的Dockerfile，讓docker-compose在build的時候能安裝plugin</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ARG</span> ELK_VERSION</span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/elastic/kibana-docker</span></span><br><span class="line"><span class="keyword">FROM</span> docker.elastic.co/kibana/kibana-oss:$&#123;ELK_VERSION&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add your kibana plugins setup here</span></span><br><span class="line"><span class="comment"># Example: RUN kibana-plugin install &lt;name|url&gt;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> kibana-plugin install https://github.com/sirensolutions/sentinl/releases/download/tag-6.5.0-0/sentinl-v6.5.4.zip</span></span><br></pre></td></tr></table></figure><p>SENTINL的版本建議和ELK一致，<a href="https://github.com/sirensolutions/sentinl/releases">這裡</a>可以找到所有版本的release</p><h2 id="設定SENTINL"><a href="#設定SENTINL" class="headerlink" title="設定SENTINL"></a>設定SENTINL</h2><p>為了讓事件發生時能發出通知，需要設定如email、slack等平台的存取權限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">## Default Kibana configuration from kibana-docker.</span><br><span class="line">## from https://github.com/elastic/kibana-docker/blob/master/build/kibana/config/kibana.yml</span><br><span class="line">#</span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: &quot;0&quot;</span><br><span class="line">elasticsearch.url: elasticsearch:9200</span><br><span class="line">sentinl:</span><br><span class="line">  settings:</span><br><span class="line">    email:</span><br><span class="line">      active: true</span><br><span class="line">      host: &quot;smtp.gmail.com&quot;</span><br><span class="line">      user: &quot;user@gmail.com&quot;</span><br><span class="line">      port: 587</span><br><span class="line">      password: password</span><br><span class="line">      tls: true</span><br><span class="line">      timeout: 20000  # mail server connection timeout</span><br><span class="line">    slack:</span><br><span class="line">      active: true</span><br><span class="line">      token: [your token]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose up</span><br></pre></td></tr></table></figure><p>這裡以GMAIL和slack做為通知平台，<a href="https://sentinl.readthedocs.io/en/latest/Config-Example/#kibana-config-for-sentinl-v6">官網</a>有其它範例。</p><p>連上管理介面應該能看到左側多了SENTINL的欄位如下:</p><p><img src="sentinl.png" alt="sentinl"></p><h2 id="使用Metricbeat收集log"><a href="#使用Metricbeat收集log" class="headerlink" title="使用Metricbeat收集log"></a>使用Metricbeat收集log</h2><p><a href="https://www.elastic.co/guide/en/beats/metricbeat/current/metricbeat-modules.html">Metricbeat</a>用來收集後端服務的log，舉凡MongoDB, Apache, Docker和Kubernetes都有相關的模組可以使用</p><ul><li>安裝Metricbeat，一樣使用docker image</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">docker stop metricbeat</span><br><span class="line">docker rm -v metricbeat</span><br><span class="line">docker run -d \</span><br><span class="line">  --name=metricbeat \</span><br><span class="line">  --hostname=</span><br><span class="line">  --volume=&quot;$(pwd)/metricbeat.yml:/usr/share/metricbeat/metricbeat.yml:ro&quot; \</span><br><span class="line">  --volume=&quot;/var/run/docker.sock:/var/run/docker.sock:ro&quot; \</span><br><span class="line">  --volume=&quot;/sys/fs/cgroup:/hostfs/sys/fs/cgroup:ro&quot; \</span><br><span class="line">  --volume=&quot;/proc:/hostfs/proc:ro&quot; \</span><br><span class="line">  --volume=&quot;/:/hostfs:ro&quot; \</span><br><span class="line">  docker.elastic.co/beats/metricbeat:6.5.4 metricbeat -e -c metricbeat.yml</span><br><span class="line">docker exec -d metricbeat metricbeat setup</span><br></pre></td></tr></table></figure><ul><li>修改metricbeat config<br>進入docker image環境，根目錄有<code>metricbeat.reference.yml</code>和<code>metricbeat.yml</code>二個檔案，前者為各種服務的設定參考；後者為乾淨的設定檔。我們在<code>metricbeat.yml</code>加入mongodb和system的設定(你也可以自訂檔名)</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metricbeat.modules:</span></span><br><span class="line">  <span class="comment">#------------ MongoDB Module ------------------------</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">module:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">metricsets:</span> [<span class="string">&quot;dbstats&quot;</span>, <span class="string">&quot;status&quot;</span>, <span class="string">&quot;collstats&quot;</span>, <span class="string">&quot;metrics&quot;</span>, <span class="string">&quot;replstatus&quot;</span>]</span><br><span class="line">    <span class="attr">period:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># The hosts must be passed as MongoDB URLs in the format:</span></span><br><span class="line">    <span class="comment"># [mongodb://][user:pass@]host[:port].</span></span><br><span class="line">    <span class="comment"># The username and password can also be set using the respective configuration</span></span><br><span class="line">    <span class="comment"># options. The credentials in the URL take precedence over the username and</span></span><br><span class="line">    <span class="comment"># password configuration options.</span></span><br><span class="line">    <span class="attr">hosts:</span> [<span class="string">&quot;localhost:27017&quot;</span>]</span><br><span class="line">    </span><br><span class="line">  <span class="comment">#============ System ===============================</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">module:</span> <span class="string">system</span></span><br><span class="line">    <span class="attr">metricsets:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cpu</span> <span class="comment"># CPU usage</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">load</span> <span class="comment"># CPU load averages</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">memory</span> <span class="comment"># Memory usage</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">network</span> <span class="comment"># Network IO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">process</span> <span class="comment"># Per process metrics</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">process_summary</span> <span class="comment"># Process summary</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">uptime</span> <span class="comment"># System Uptime</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">core</span> <span class="comment"># Per CPU core usage</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">diskio</span> <span class="comment"># Disk IO</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">filesystem</span> <span class="comment"># File system usage for each mountpoint</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">fsstat</span> <span class="comment"># File system summary metrics</span></span><br><span class="line">      <span class="comment">#- raid           # Raid</span></span><br><span class="line">      <span class="comment">#- socket         # Sockets and connection info (linux only)</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">period:</span> <span class="string">1m</span></span><br><span class="line">    <span class="attr">processes:</span> [<span class="string">&quot;.*&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Configure the metric types that are included by these metricsets.</span></span><br><span class="line">    <span class="attr">cpu.metrics:</span> [<span class="string">&quot;percentages&quot;</span>] <span class="comment"># The other available options are normalized_percentages and ticks.</span></span><br><span class="line">    <span class="attr">core.metrics:</span> [<span class="string">&quot;percentages&quot;</span>] <span class="comment"># The other available option is ticks</span></span><br></pre></td></tr></table></figure><p>這裡節錄module的部分，Kibana和Elasticsearch的host需要根據環境修改</p><ul><li>啓動 Metricbeat</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh docker_metricbeat.sh</span><br></pre></td></tr></table></figure><h2 id="Kibana-dashboard"><a href="#Kibana-dashboard" class="headerlink" title="Kibana dashboard"></a>Kibana dashboard</h2><p>在瀏覽器進入kibana的介面，在<strong>Management</strong>/<strong>Index Patterns</strong>確認有<code>metricbeat-*</code>的index，將它設為default index。</p><p>在<strong>Dashboard</strong>裡可以找到<code>[Metricbeat System] Overview</code>與<code>[Metricbeat MongoDB] Overview</code>這二個dashboard，點進去應該能看到以下的畫面</p><p><img src="mongodb.png" alt="mongodb"></p><p><img src="system.png" alt="system"></p><p>到這裡己經能看到系統的狀態，接下來要設定watcher讓狀況發生時能通知管理者。</p><p>參考:</p><p><a href="https://dzone.com/articles/watchingalerting-on-real-time-data-in-elasticsearc">Watching/Alerting on Real-Time Data in Elasticsearch Using Kibana and SentiNL</a></p><p><a href="https://blog.yowko.com/elk-mongodb-monitor/">使用Elastic Stack(ELK)來監控MongoDB</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近研究如何使用ELK(Elasticsearch, Logstash和Kibana)監控MongoDB的效能，之前公司己經使用ELK監控爬蟲，這次試著擴大範圍並加入告警的通知。&lt;br&gt;
    
    </summary>
    
    
      <category term="mongodb" scheme="https://alexliang.me/tags/mongodb/"/>
    
      <category term="elk" scheme="https://alexliang.me/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>Mocha跑測試時hang住的偵錯方法</title>
    <link href="https://alexliang.me/Mocha%E8%B7%91%E6%B8%AC%E8%A9%A6%E6%99%82hang%E4%BD%8F%E7%9A%84%E5%81%B5%E9%8C%AF%E6%96%B9%E6%B3%95/"/>
    <id>https://alexliang.me/Mocha跑測試時hang住的偵錯方法/</id>
    <published>2019-01-16T00:29:16.000Z</published>
    <updated>2019-01-19T03:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>前陣子同事改完API server，local跑完測試沒問題後便推上CI/CD，沒想到mocha跑完測項卻沒正常結束而hang住。</p><p>檢查了環境(node版本,package)都沒差異後，另一位同事找到<a href="https://gist.github.com/boneskull/7fe75b63d613fa940db7ec990a5f5843">async hooks</a>來偵錯</p><span id="more"></span><p>此手法利用<code>async_hooks</code>建立hook監聽非同步事件的生命週期</p><p>在範例中，將async hook抓到的error log放在mocha的<code>after</code> block印出來。可以發現是該程式碼連上server server開始監聽某個port之後卻沒結束連線，造成測試過了卻停住。</p><p>同事遇到的情況也是如此，API service的測試因某些原因造成Kibana的連線沒有結束，導致測試停住。</p><p><code>async_hooks</code>在node 8以後才支援，如果要監聽非同步事件可以參考。</p><p>參考資料: <a href="https://nodejs.org/api/async_hooks.html">NodeJS Async Hooks官方文件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前陣子同事改完API server，local跑完測試沒問題後便推上CI/CD，沒想到mocha跑完測項卻沒正常結束而hang住。&lt;/p&gt;
&lt;p&gt;檢查了環境(node版本,package)都沒差異後，另一位同事找到&lt;a href=&quot;https://gist.github.com/boneskull/7fe75b63d613fa940db7ec990a5f5843&quot;&gt;async hooks&lt;/a&gt;來偵錯&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://alexliang.me/tags/javascript/"/>
    
  </entry>
  
</feed>
